{"argv": "from sys import argv\nprint(argv) # prints all args\nprint(argv[0]) # is always the name of the program\n# caution!\n# the below line will fail if at least 2 arguments aren't passed in to the program!\nprint(argv[1], argv[2])", "collections_instantiations": "my_list = [1, 2, 3, 4]\nmy_tuple = (1, 2, 3)\nmy_tuple_single_item = (1,)  # note the comma here!\nmy_dictionary = {'key': 'value', 1: 2}\nmy_set = {1, 2}\nmy_big_list = [\n    'lorem ipsum',\n    123456,\n    'foo bar baz',\n    7890\n]\nprint(my_list, my_tuple, my_tuple_single_item)\nprint(my_set, my_dictionary)\nprint(my_big_list)", "collections_item_access": "# lists\nour_list = ['foo', 'bar', 'baz']\nprint(len(our_list)) # 3\nprint(our_list[0]) # foo\nprint(our_list[1]) # bar\nprint(our_list[-1]) # baz\nprint(our_list[:2]) # foo, bar - beginning to second element\nprint(our_list[1:]) # bar, baz - index 1 to end\nfor item in our_list:\n    print(item)\n# dictionaries\nour_dict = {'key': 'value', 13: 42}\nprint(len(our_dict))\nprint(our_dict['key']) # 'value'\nprint(our_dict[13]) # 42\nfor key in our_dict:\n    print(key)\nfor value in our_dict.values():\n    print(value)\nfor key, value in our_dict.items():\n    print(key, value)", "conditions_boolean_logic": "# Experimenting with conditional logic can be more convenient in the interpreter\nvar_1 = 'Foo'\nvar_2 = 'Bar'\n\nif var_1 == 'Foo' and var_2 == 'Foo':\n    print('All Foo!')\n\nif var_1 == 'Foo' or var_2 == 'Foo':\n    print('At least one var is Foo!')\n\nif not var_1 or not var_2:\n    print('At least one var is falsey!')\n\nlength_var_1 = len(var_1)\nlength_var_2 = len(var_2)\n\nif length_var_1 == length_var_2 and length_var_1 + length_var_2 > 10:\n    print('Same length AND combined length longer than ten!')\n\nif length_var_1 == length_var_2 or length_var_1 + length_var_2 > 10:\n    print('Same length OR combined length longer than ten!')", "conditions_indent": "if True:\n    print('True is true...')\n    print('You\\'ll see this get printed too!')", "conditions_names": "user_input = input('What\\'s your name?')\nif user_input == 'max':\n    print('Weirdo')\nelif user_input == 'jax':\n    print('Cool name!')\nelse:\n    print('Hello, ' + user_input)", "file_io": "with open('my_file.txt', 'w', encoding='ascii') as f: # second argument is the mode to open the file in, w is for write\n    # encoding above refers to how bytes translates to characters.\n    # ascii is very common for simple english text and special characters.\n    # utf-8 covers characters from many languages, and even emojis\n    # character encodings are an interesting topic for further reading if you're curious\n    f.write('This is both the beginning\\nand the end\\n')\n\nwith open('my_file.txt', 'a', encoding='ascii') as f: # a is for append\n    f.write('This is the new end\\n')\n\nwith open('my_file.txt', 'r', encoding='ascii') as f: # r for read\n    for i, line in enumerate(f):\n        print(f'line {i}: {line}', end='') # we can tell print not to add a new line at the end\n        # we already have new lines on the lines we are reading\n\nwith open('my_file.txt', 'r+', encoding='ascii') as f: # r+ for read and write\n    f.seek(17) # advance forward in the file 17 characters\n    f.write('foobarbaz')\n    f.seek(0) # back to the beginning!\n    print(f.readline()) # let's see the result", "functions_define": "def add_2(num_1, num_2):\n    return num_1 + num_2\n\ndef print_collection(collection):\n    for item in collection:\n        print(item)\n\ndef add_2_default_args(num_1=8, num_2=4):\n    return num_1 + num_2\n\nvalue_1 = 10\nvalue_2 = 20\nprint(add_2(value_1, value_2)) # 30\nprint(add_2(3, 6)) # 9\nprint(add_2_default_args()) # 12\nprint(add_2_default_args(10)) # 14\nprint(add_2_default_args(num_2=0)) # 8\nlist_1 = [1, 1, 2, 3, 5, 8, 13]\nprint_collection(list_1)", "functions_splat": "def sum_4_long_signature(num_1, num_2, num_3, num_4):\n    return num_1 + num_2 + num_3 + num_4\n\ndef sum_many(list_nums):\n    accumulator = 0\n    for num in list_nums:\n        accumulator += num\n    return accumulator\n\n# in a function signature, * represents variable positional arguments and will be represented as a tuple.\n# ** represents variable keyword arguments and will be represented as a dictionary\ndef varargs(*args, **kwargs):\n    print(args)\n    print(kwargs)\n\nmy_list = [1, 2, 3, 4]\nresult_1 = sum_4_long_signature(*my_list) # splat operator unpacks a list or tuple, double splat (**) unpacks a dictionary\nresult_2 = sum_many(my_list)\nif result_1 == result_2:\n    print(f'Both methods agree; sum of 1, 2, 3, 4 is {result_1}')\n\nvarargs(1, 2, 3, key='value', foo='bar')\n# (1, 2, 3)\n# {'key': 'value', 'foo': 'bar'}", "futures_sock_continue": "from time import sleep\nimport socket\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n    sock.connect(('127.0.0.1', 12345))  # host, port\n    sock.setblocking(False)\n    while True:\n        try:\n            data = sock.recv(1)  # unordinarily small receive size for demonstration purposes\n        except TimeoutError:\n            pass\n        if data:\n            print(f'received {data}')\n            continue\n        sleep(0.5)", "futures_try_int_input": "# preview of the future\n# if we begin a line with a '#', Python will ignore it\n# these lines are called comments\n# they can be useful for documenting important things in your code\n# leaving notes for yourself and others can be very important as you write more code\n# its not uncommon to return to code after just a week away and have no idea where you left off or why...\n\nmy_number_as_string = input()\ntry:\n    my_number = int(my_number_as_string)\nexcept ValueError:\n    # Python has several builtin error types, knowing when and how to reference the documentation is a valuable skill in its own right\n    print('That\\'s not a number!')\nelse:\n    print(my_number * 2)", "guessing_game": "from random import randint\n\nwhile input('Play game? y/n: ') == 'y':\n    answer = randint(1, 100)\n    guess = int(input('Guess a number between 1 and 100: ').strip())\n    if guess == answer:\n        print('You win!')\n    else:\n        print('You lose!')\nprint('Game over!')", "hello_world": "print('Hello world')", "imports_1": "import example_b\nexample_b.some_function() # variables and functions defined inside of example_b can be accessed like so", "input_and_print": "my_variable = input()\nprint('You typed: ' + my_variable)", "input_and_print_double_v1": "my_number = int(input())\nprint(my_number * 2)", "input_and_print_double_v2": "my_number = input()\nprint(int(my_number) * 2)", "input_and_print_double_v3": "print(int(input()) * 2)", "input_and_print_double_v4": "my_number = input()\nmy_number = int(my_number)\nprint(my_number * 2)", "input_and_print_twice": "my_number = input()\nprint(my_number * 2)", "input_noop": "input()", "loops_2_var_counter": "counter = 0\ntarget = 3\nwhile counter < target:\n    val = input(f'You have typed \\'q\\' {counter} times. Type \\'q\\' and press enter {target - counter} times to exit.\\n')\n    if val == 'q':\n        counter += 1  # equivalent to `counter = counter + 1`\n    print('Loopedy loop...')", "loops_input_to_break": "while True:\n    user_input = input('Type \\'q\\' to exit')\n    if user_input == 'q':\n        break\n    # An alternate way to format strings, note the f before the lead quote, and the braces around the variable name\n    print(f'You said, {user_input}')", "loops_scream": "while True:\n    print('hello...', end='')", "loops_simple_continue": "i = 0\nwhile i < 10:\n    i += 1\n    if i in {3, 7}:\n        continue\n    print(i)", "random_numbers": "import random\n\nfor _ in range(10):\n    print(random.randint(1, 100))", "requests_demo": "import requests\nresponse = requests.get('http://example.com')\nprint(response.text)", "soup_demo": "from bs4 import BeautifulSoup\nimport requests\nresponse = requests.get('http://example.com')\nhtml_doc = response.text\nsoup = BeautifulSoup(html_doc, 'html.parser')\nheaders = soup.find_all('h1')\nprint(headers[0].text)", "variables_assignments": "# assignment as statement\nmy_var = foo()\nif my_var:\n    print(my_var)\n# assignment as expression, using 'walrus' operator\n# NOTE: The walrus operator only works on Python3.8+\nif my_var := foo():\n    print(my_var)\n\n# a more complicated example\nif (var_1 := foo()) and (var_2 := bar()):\n    do_something(var_1, var_2)"}