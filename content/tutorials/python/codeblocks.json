{"collections_instantiations": "my_list = [1, 2, 3, 4]\n\nmy_tuple = (1, 2, 3)\nmy_tuple_single_item = (1,)  # note the comma here!\n\nmy_dictionary = {'key': 'value', 1: 2}\n\nmy_set = {1, 2}\n\nmy_other_list = [\n    'lorem ipsum',\n    123456,\n    'foo bar baz',\n    7890\n]\nprint(my_list, my_tuple, my_tuple_single_item)\nprint(my_set, my_dictionary)\nprint(my_other_list)", "collections_item_access_1": "our_list = ['foo', 'bar', 'baz']\nprint(len(our_list)) # 3 - len short for length\nprint(our_list[0]) # foo\nprint(our_list[1]) # bar\nprint(our_list[-1]) # baz\nprint(our_list[:2]) # foo, bar - beginning to second element\nprint(our_list[1:]) # bar, baz - index 1 to end", "collections_item_access_2": "our_dict = {'key': 'value', 13: 42}\nprint(len(our_dict))\nprint(our_dict['key']) # 'value'\nprint(our_dict[13]) # 42", "collections_item_access_3": "our_list = ['foo', 'bar', 'baz']\n\nfor item in our_list:\n    print(item)\n\nour_dict = {'key': 'value', 13: 42}\n\nfor key in our_dict:\n    print(key)\nfor value in our_dict.values():\n    print(value)\nfor key, value in our_dict.items():\n    print(key, value)", "conditions_boolean_logic": "# Experimenting with conditional logic can be more convenient in the interpreter\nvar_1 = 'Foo'\nvar_2 = 'Bar'\n\nif var_1 == 'Foo' and var_2 == 'Foo':\n    print('All Foo!')\n\nif var_1 == 'Foo' or var_2 == 'Foo':\n    print('At least one var is Foo!')\n\nif not var_1 or not var_2:\n    print('At least one var is falsey!')", "conditions_indent": "if True:\n    print('True is true...')\n    print('You\\'ll see this get printed too!')", "conditions_names": "user_input = input('What\\'s your name?')\nif user_input == 'Joshua':\n    print('Greetings.  Would you like to play a game?')\nelif user_input == 'Dave':\n    print(\"I'm sorry, Dave.  I'm afraid I still can't open the podbay doors.\")\nelse:\n    print('Hello, ' + user_input)", "conditions_string_lower": "name = input().lower()\n\n# OR\n\nname = input()\nlowercase_name = name.lower()", "functions_default_args": "def add_2_default_args(num_1=8, num_2=4):\n    return num_1 + num_2\n\nprint(add_2_default_args()) # 12\nprint(add_2_default_args(10)) # 14\nprint(add_2_default_args(num_2=0)) # 8", "functions_define": "def add_2(num_1, num_2):\n    return num_1 + num_2\n\nvalue_1 = 10\nvalue_2 = 20\nprint(add_2(value_1, value_2)) # 30\nprint(add_2(3, 6)) # 9\nprint(add_2(num_2=3, num_1=6)) # still 9", "functions_docstring_pass": "def func():\n    \"\"\"\n    Inside these triple quotes, you will find documentation\n    for this function. These special comments are called\n    docstrings.\n    \"\"\"\n    pass  # Do nothing statement.\n    # Not necessary here, the docstring is enough for an empty function", "functions_splat": "def sum_4_long_signature(num_1, num_2, num_3, num_4):\n    return num_1 + num_2 + num_3 + num_4\n\ndef sum_many(list_nums):\n    accumulator = 0\n    for num in list_nums:\n        accumulator += num\n    return accumulator\n\n# in a function signature, * represents variable positional arguments and will be represented as a tuple.\n# ** represents variable keyword arguments and will be represented as a dictionary\ndef varargs(*args, **kwargs):\n    print(args)\n    print(kwargs)\n\nmy_list = [1, 2, 3, 4]\nresult_1 = sum_4_long_signature(*my_list) # splat operator unpacks a list or tuple, double splat (**) unpacks a dictionary\nresult_2 = sum_many(my_list)\nif result_1 == result_2:\n    print(f'Both methods agree; sum of 1, 2, 3, 4 is {result_1}')\n\nvarargs(1, 2, 3, key='value', foo='bar')\n# (1, 2, 3)\n# {'key': 'value', 'foo': 'bar'}", "futures_sock_continue": "from time import sleep\nimport socket\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n    sock.connect(('127.0.0.1', 12345))  # host, port\n    sock.setblocking(False)\n    while True:\n        try:\n            data = sock.recv(1)  # unordinarily small receive size for demonstration purposes\n        except TimeoutError:\n            pass\n        if data:\n            print(f'received {data}')\n            continue\n        sleep(0.5)", "futures_try_int_input": "# preview of the future\n# if we begin a line with a '#', Python will ignore it\n# these lines are called comments\n# they can be useful for documenting important things in your code\n# leaving notes for yourself and others can be very important as you write more code\n# its not uncommon to return to code after just a week away and have no idea where you left off or why...\n\nmy_number_as_string = input()\ntry:\n    my_number = int(my_number_as_string)\nexcept ValueError:\n    # Python has several builtin error types, knowing when and how\n    # to reference the documentation is a valuable skill in its own right\n    print('That\\'s not a number!')\nelse:\n    print(my_number * 2)", "hello_world": "print('Hello world')", "input_and_print": "my_variable = input()\nprint('You typed: ' + my_variable)", "input_and_print_double_v1": "my_number = int(input())\nprint(my_number * 2)", "input_and_print_double_v2": "my_number = input()\nprint(int(my_number) * 2)", "input_and_print_double_v3": "print(int(input()) * 2)", "input_and_print_double_v4": "my_number = input()\nmy_number = int(my_number)\nprint(my_number * 2)", "input_and_print_twice": "my_number = input()\nprint(my_number * 2)", "input_noop": "input()", "loops_2_var_counter": "counter = 0\ntarget = 3\nwhile counter < target:\n    val = input(f'You have typed \\'q\\' {counter} times. Type \\'q\\' and press enter {target - counter} times to exit.\\n')\n    if val == 'q':\n        counter += 1  # equivalent to `counter = counter + 1`\n    print('Loopedy loop...')", "loops_input_no_break": "while (user_input := input('Type \\'q\\' to exit')) != \"q\":\n    print(f'You said, {user_input}')", "loops_input_to_break": "while True:\n    user_input = input('Type \\'q\\' to exit')\n    if user_input == 'q':\n        break\n    # An alternate way to format strings, note the f before the lead quote, and the braces around the variable name\n    print(f'You said, {user_input}')", "loops_scream": "while True:\n    print('hello...', end='')", "loops_simple_continue": "i = 0\nwhile i < 10:\n    i += 1\n    if i in {3, 7}:\n        continue\n    print(i)", "recursion": "def fibonacci_sequence(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fibonacci_sequence(n - 1) + fibonacci_sequence(n - 2)\n\nprint(fibonacci_sequence(7))\n# 0, 1, 1, 2, 3, 5, 8, 13", "argv": "from sys import argv\nprint(argv) # prints all args\nprint(argv[0]) # is always the name of the program\n# caution!\n# the below line will fail if at least 2 arguments aren't passed in to the program!\nprint(argv[1], argv[2])", "file_io": "with open('my_file.txt', 'w', encoding='ascii') as f: # second argument is the mode to open the file in, w is for write\n    # encoding above refers to how bytes translates to characters.\n    # ascii is very common for simple english text and special characters.\n    # utf-8 covers characters from many languages, and even emojis\n    # character encodings are an interesting topic for further reading if you're curious\n    f.write('This is both the beginning\\nand the end\\n')\n\nwith open('my_file.txt', 'a', encoding='ascii') as f: # a is for append\n    f.write('This is the new end\\n')\n\nwith open('my_file.txt', 'r', encoding='ascii') as f: # r for read\n    for i, line in enumerate(f):\n        print(f'line {i}: {line}', end='') # we can tell print not to add a new line at the end\n        # we already have new lines on the lines we are reading\n\nwith open('my_file.txt', 'r+', encoding='ascii') as f: # r+ for read and write\n    f.seek(17) # advance forward in the file 17 characters\n    f.write('foobarbaz')\n    f.seek(0) # back to the beginning!\n    print(f.readline()) # let's see the result", "guessing_game": "from random import randint\n\nwhile input('Play game? y/n: ') == 'y':\n    answer = randint(1, 100)\n    guess = int(input('Guess a number between 1 and 100: ').strip())\n    if guess == answer:\n        print('You win!')\n    else:\n        print('You lose!')\nprint('Game over!')", "imports_1": "import example_b\n# variables and functions defined inside of example_b can be accessed like so:\nexample_b.some_function()", "random_numbers": "import random\n\nfor _ in range(10):\n    print(random.randint(1, 100))", "requests_demo": "import requests\nresponse = requests.get('http://example.com')\nprint(response.text)", "soup_demo": "from bs4 import BeautifulSoup\nimport requests\nresponse = requests.get('http://example.com')\nhtml_doc = response.text\nsoup = BeautifulSoup(html_doc, 'html.parser')\nheaders = soup.find_all('h1')\nprint(headers[0].text)", "mutable_objects_copy": "import copy\nlist_1 = [1, 2, 3]\nlist_2 = copy.copy(list_1)\nlist_1.append(4)\nprint(list_2)  # [1, 2, 3]\n\n# alternatively, you may copy a list with the following syntax:\nlist_3 = list_1[:]\n\n# dictionaries have a copy method, saving you an import\ndict_1 = {1: 2}\ndict_2 = dict_1.copy()", "mutable_objects_no_copy": "list_1 = [1, 2, 3]\nlist_2 = list_1  # this does not copy the list\n# both variables will reference the same list\nlist_1.append(4)\nprint(list_2)  # [1, 2, 3, 4]", "runtime_variable_resolution": "i = 15\ndef foo():\n    print(i)\ni = 3\nfoo()  # 3", "variables_assignments": "# assignment as statement\nmy_var = foo()\nif my_var:\n    print(my_var)\n# assignment as expression, using 'walrus' operator\n# NOTE: The walrus operator only works on Python3.8+\nif my_var := foo():\n    print(my_var)\n\n# a more complicated example\nif (var_1 := foo()) and (var_2 := bar()):\n    do_something(var_1, var_2)", "variables_block_scope_bad": "if True:\n    print(\"do something\")\nelse:\n    var_1 = True\nprint(var_1)  # UnboundLocalError", "variables_block_scope_good": "if True:\n    var_1 = 100.13\nelse:\n    var_1 = -33.12\nprint(var_1)  # 100.13", "variables_mutating_outer_scope": "var_1 = 9.3\n\ndef func_1():\n    # accessing variables from an outer scope works fine\n    print(var_1)\n\nfunc_1()  # 9.3\n\ndef func_2():\n    # trying to change them will not work as expected\n    var_1 = 0.0\n    print(var_1)\n\nfunc_2()  # 0.0\nprint(var_1)  # 9.3\n\ndef func_3():\n    # the global keyword here grants the ability to modify var_1\n    global var_1\n    var_1 = 'foo'\n\nfunc_3()\nprint(var_1)  # 'foo'", "variables_nonlocal": "def outer_func():\n    var_1 = 42\n    def inner_func():\n        nonlocal var_1\n        var_1 = 13\n    print(var_1)  # 42\n    inner_func()\n    print(var_1)  # 13\nouter_func()", "variables_scope": "var_1 = 2\ndef func_1():\n    # functions have their own scope\n    var_2 = 3\n\nprint(var_1)  # 2\nprint(var_2)  # NameError", "variables_underscore_as_unused": "# we don't need the numbers in the range, we just want to do an action n times\nfor _ in range(3):\n    print(\"hello\")\n\ndef returns_two():\n    return 3, 'foo'\n\n# we do not intend to use the first element of the returned tuple\n_, my_var = returns_two()", "callable_type": "class CallableType:\n    def __call__(self):\n        print(\"You rang?\")", "class_dunder_eq": "class Foo:\n    def __init__(self, value):\n        self.value = value\n\n    def __eq__(self, other):\n        return self.value == other.value", "context_manager_type": "class ContextManagerType:\n    def __enter__(self):\n        print(\"setup! here's a foo!\")\n        return \"foo\"\n    def __exit__(self, *args, **kwargs):\n        print(\"cleanup!\")", "dataclasses": "from dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    age: int = 0", "enum_ints": "from enum import Enum\n\n# The below syntax represents inheritance\n# This means that our class StoplightColors has all of the properties\n# of the Enum class\nclass StoplightColors(Enum):\n    # You must assign an integer to each enumerated value\n    GREEN = 1\n    YELLOW = 2\n    RED = 3", "enum_str": "# The below syntax represents multiple inheritance\n# This gives the properties of both str and Enum to our class\n# This may be useful if we want to retrieve a string value instead of an integer value\n# Python 3.11 adds a StrEnum class that you can import that gives this functionality with a few extra features.\nclass StoplightColors(str, Enum):\n    GREEN = 'green'\n    YELLOW = 'yellow'\n    RED = 'red'", "first_class": "class MyType:\n    class_attribute = 0\n    def __init__(self, arg):\n        self.regular_attribute = arg\n        MyType.class_attribute += 1\n        self.instance = MyType.class_attribute\n\n    def my_method(self):\n        print(f\"Instance: {self.instance}, Regular Attribute: {self.regular_attribute}\")", "person_class": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greet(self, person):\n        print(f'Hello, {person.name}, my name is {self.name}!')\n\n    def birthday(self):\n        self.age += 1", "bare_except": "try:\n    result = delta(0)\nexcept:\n    print(\"That didn't work, let's carry on and try something else\")", "control_flow_else": "try:\n    n = delta(0)\nexcept:\n    print(\"Fail\")\nelse:\n    print(\"Success\")", "control_flow_finally": "import random\n\ndef fail_maybe():\n    num = random.randint(0, 1)\n    if num == 1:\n        raise RuntimeError()\n\ntry:\n    fail_maybe()\nexcept RuntimeError:\n    print(\"I only print when an error occurs\")\nelse:\n    print(\"I only print when no error occurs\")\nfinally:\n    print(\"I will print every time\")", "create_your_own": "class MyException(Exception):\n    \"\"\"Raised when the bad thing happens\"\"\"\n\nclass MyExceptionChild(MyException):\n    pass", "delta_original": "def delta(x):\n    return abs(1 / x)", "divide_by_zero_guard": "def delta(x):\n    if x == 0:\n        return None\n    return abs(1 / x)", "less_broad": "task_1()\ntask_2()\n\ntry:\n    task_3()\nexcept TaskError as e:\n    print(f\"Task 3 failed! {e}\")\n    return None\nelse:\n    print(\"About to do task 4\")\n    task_4()\n    foo = 2 + task_5()\n    return foo, task_6()\nfinally:\n    cleanup()", "more_guards": "def delta(x):\n    if x == 0 or not isinstance(x, (float, int)):\n        return None\n    return abs(1 / x)", "nonbare_excepts": "try:\n    result = delta(0)\nexcept ZeroDivisionError:\n    print(\"You tried to divide by zero!\")\nexcept TypeError:\n    print(\"You tried dividing something that is not divisible!\")\n\n# OR\n\ntry:\n    result = delta(0)\nexcept (ZeroDivisionError, TypeError):\n    print(\"Whoops!\")", "overly_broad_is_bad": "try:\n    task_1()\n    task_2()\n    task_3()\n    print(\"About to do task 4\")\n    task_4()\n    foo = 2 + task_5()\n    cleanup()\n    return foo, task_6()\nexcept:\n    print(\"Something went wrong!\")\n    return None", "raise_your_own_1": "def func():\n    raise RuntimeError(\"Optional information goes here\")", "raise_your_own_2": "def func(num):\n    try:\n        return 2 / num\n    except ZeroDivisionError as e:\n        raise RuntimeError from e"}